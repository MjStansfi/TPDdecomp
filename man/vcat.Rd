% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helper_functions.R
\name{vcat}
\alias{vcat}
\title{cat function with built in verbosity}
\usage{
vcat(..., sep = " ", bypass = FALSE)
}
\arguments{
\item{...}{Things to cat}

\item{sep}{a character string to separate each element.}

\item{bypass}{logical. If bypass == T print regardless of other factors.}
}
\description{
Depending on the parent frame's "verbose" logical object state (T/F), cat R object(s).
}
\details{
Outputs the objects, concatenating the representations. cat performs much less conversion than print.
}
\examples{
\dontrun{
dog <- ("dog")

# With no verbose object in the env, and bypass not true, vcat does nothing
vcat(dog)

# Dummy function with verbose as an argument to show "local" environment interactions
foo <- function(verbose = FALSE){
  vcat(dog)
}

# Create a global variable verbose set to TRUE
verbose <-  T
# vcat and foo() now both print the dog object, even though foo's local verbose variable is false. 
# i.e. a global verbose veriable will take precedence over a local one
vcat(dog)
foo(verbose = FALSE)

# With the global verbose object set to FALSE, a direct vcat call does nothing, and if the foo function
# is given TRUE for it's local verbose object, then the 'dog' object is still not printed. As above, 
the global variable takes precedence.
verbose <- F
vcat(dog)
foo()
foo(verbose = TRUE)

# However if there is no global verbose variable, a local variable will cause it to print
rm(verbose)
foo(verbose = TRUE) 
}

}
\seealso{
\link{vprint}
}
